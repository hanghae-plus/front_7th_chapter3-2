# 함수형 프로그래밍 가이드: 액션, 계산, 데이터

## 개요

함수형 프로그래밍에서는 코드를 **액션(Action)**, **계산(Calculation)**, **데이터(Data)**로 분리하여 작성하는 것이 핵심 원칙입니다. 이러한 분리를 통해 코드의 가독성, 유지보수성, 테스트 용이성을 크게 향상시킬 수 있습니다.

---

## 1. 데이터 (Data)

### 정의
데이터는 이벤트에 대한 사실을 기록한 값입니다. 변경되지 않는 불변성(Immutability)을 유지하는 것이 중요합니다.

### 특징
- **불변성**: 한 번 생성되면 변경되지 않음
- **해석 가능**: 데이터 자체는 의미를 가지지 않으며, 해석하는 코드에 따라 의미가 결정됨
- **비교 가능**: 같은 데이터는 항상 같음 (참조 비교가 아닌 값 비교)

### 예시

```typescript
// ✅ 좋은 예: 불변 데이터
export interface Product {
  id: string;
  name: string;
  price: number;
  stock: number;
  discounts: Discount[];
}

export interface CartItem {
  product: Product;
  quantity: number;
}

export interface Coupon {
  name: string;
  code: string;
  discountType: 'amount' | 'percentage';
  discountValue: number;
}

// 데이터 생성
const product: Product = {
  id: 'p1',
  name: '노트북',
  price: 1000000,
  stock: 10,
  discounts: [{ quantity: 5, rate: 0.1 }]
};

// ❌ 나쁜 예: 데이터를 직접 변경
product.price = 900000; // 원본 데이터 변경

// ✅ 좋은 예: 새로운 데이터 생성
const discountedProduct = {
  ...product,
  price: 900000
};
```

### 데이터 사용 원칙
1. **불변성 유지**: 데이터를 직접 수정하지 않고, 새로운 데이터를 생성
2. **타입 명확화**: TypeScript를 사용하여 데이터 구조를 명확히 정의
3. **계층적 구조**: 복잡한 데이터는 작은 단위로 분리

---

## 2. 계산 (Calculation)

### 정의
계산은 동일한 입력에 대해 항상 동일한 출력을 반환하는 순수 함수(Pure Function)입니다. 부수 효과(Side Effect)가 없으며, 실행 시점과 횟수에 의존하지 않습니다.

### 특징
- **순수성**: 부수 효과가 없음
- **참조 투명성**: 같은 입력에 대해 항상 같은 출력
- **테스트 용이성**: 외부 의존성이 없어 테스트하기 쉬움
- **재사용성**: 다양한 컨텍스트에서 재사용 가능

### 예시

```typescript
// ✅ 좋은 예: 순수 함수 (계산)
export function getRemainingStock(
  product: Product,
  cart: CartItem[]
): number {
  const cartItem = cart.find(item => item.product.id === product.id);
  const remaining = product.stock - (cartItem?.quantity || 0);
  return remaining;
}

export function getMaxApplicableDiscount(
  item: CartItem,
  cart: CartItem[]
): number {
  const { discounts } = item.product;
  const { quantity } = item;

  const baseDiscount = discounts.reduce((maxDiscount, discount) => {
    return quantity >= discount.quantity && discount.rate > maxDiscount
      ? discount.rate
      : maxDiscount;
  }, 0);

  const hasBulkPurchase = cart.some(cartItem => cartItem.quantity >= 10);
  if (hasBulkPurchase) {
    return Math.min(baseDiscount + 0.05, 0.5);
  }

  return baseDiscount;
}

export function calculateItemTotal(
  item: CartItem,
  cart: CartItem[]
): number {
  const { price } = item.product;
  const { quantity } = item;
  const discount = getMaxApplicableDiscount(item, cart);
  return Math.round(price * quantity * (1 - discount));
}

export function calculateCartTotals(
  cart: CartItem[],
  selectedCoupon: Coupon | null
): { totalBeforeDiscount: number; totalAfterDiscount: number } {
  let totalBeforeDiscount = 0;
  let totalAfterDiscount = 0;

  cart.forEach(item => {
    const itemPrice = item.product.price * item.quantity;
    totalBeforeDiscount += itemPrice;
    totalAfterDiscount += calculateItemTotal(item, cart);
  });

  if (selectedCoupon) {
    if (selectedCoupon.discountType === 'amount') {
      totalAfterDiscount = Math.max(0, totalAfterDiscount - selectedCoupon.discountValue);
    } else {
      totalAfterDiscount = Math.round(
        totalAfterDiscount * (1 - selectedCoupon.discountValue / 100)
      );
    }
  }

  return {
    totalBeforeDiscount: Math.round(totalBeforeDiscount),
    totalAfterDiscount: Math.round(totalAfterDiscount),
  };
}

// ❌ 나쁜 예: 부수 효과가 있는 함수
let cache: number | null = null;
function calculateTotal(cart: CartItem[]) {
  if (cache) return cache; // 외부 상태에 의존
  cache = cart.reduce((sum, item) => sum + item.product.price * item.quantity, 0);
  console.log('계산 완료'); // 부수 효과
  return cache;
}
```

### 계산 함수 작성 원칙
1. **순수성 유지**: 외부 상태를 읽거나 변경하지 않음
2. **명확한 입력/출력**: 모든 필요한 데이터를 파라미터로 받음
3. **독립성**: 다른 계산 함수를 조합하여 사용 가능
4. **테스트 가능**: 단위 테스트 작성이 쉬워야 함

### 계산 함수 분리 전략
```typescript
// ❌ 나쁜 예: Hook 내부에 계산 로직이 섞여 있음
export function useCart() {
  const [cart, setCart] = useState<CartItem[]>([]);
  
  const calculateTotal = useCallback(() => {
    // 계산 로직이 Hook 내부에 있음
    return cart.reduce((sum, item) => sum + item.product.price * item.quantity, 0);
  }, [cart]);
  
  return { cart, calculateTotal };
}

// ✅ 좋은 예: 계산 함수를 별도 파일로 분리
// utils/cartCalculations.ts
export function calculateCartTotal(cart: CartItem[]): number {
  return cart.reduce((sum, item) => sum + item.product.price * item.quantity, 0);
}

// hooks/useCart.ts
import { calculateCartTotal } from '../utils/cartCalculations';

export function useCart() {
  const [cart, setCart] = useState<CartItem[]>([]);
  
  const total = useMemo(() => calculateCartTotal(cart), [cart]);
  
  return { cart, total };
}
```

---

## 3. 액션 (Action)

### 정의
액션은 실행 시점과 횟수에 의존하며, 부수 효과를 일으키는 작업입니다. 예를 들어, 상태 변경, API 호출, localStorage 읽기/쓰기, DOM 조작 등이 이에 해당합니다.

### 특징
- **부수 효과**: 외부 상태를 변경하거나 읽음
- **시점 의존성**: 언제 실행되느냐가 중요함
- **횟수 의존성**: 몇 번 실행되느냐가 중요함
- **예측 어려움**: 같은 입력이라도 실행 시점에 따라 다른 결과를 낼 수 있음

### 예시

```typescript
// ✅ 좋은 예: 액션을 명확히 분리
export function useCart() {
  const [cart, setCart] = useState<CartItem[]>([]);
  const [selectedCoupon, setSelectedCoupon] = useState<Coupon | null>(null);

  // 액션: localStorage에 저장 (부수 효과)
  useEffect(() => {
    if (cart.length > 0) {
      localStorage.setItem('cart', JSON.stringify(cart));
    } else {
      localStorage.removeItem('cart');
    }
  }, [cart]);

  // 액션: 장바구니에 상품 추가 (상태 변경)
  const addToCart = useCallback((product: Product) => {
    const remainingStock = getRemainingStock(product, cart);
    if (remainingStock <= 0) {
      return { ok: false as const, reason: 'OUT_OF_STOCK' as const };
    }

    setCart(prevCart => {
      const existingItem = prevCart.find(item => item.product.id === product.id);
      if (existingItem) {
        const newQuantity = existingItem.quantity + 1;
        if (newQuantity > product.stock) {
          return prevCart;
        }
        return prevCart.map(item =>
          item.product.id === product.id ? { ...item, quantity: newQuantity } : item
        );
      }
      return [...prevCart, { product, quantity: 1 }];
    });

    return { ok: true as const };
  }, [cart]);

  // 액션: 장바구니에서 상품 제거 (상태 변경)
  const removeFromCart = useCallback((productId: string) => {
    setCart(prevCart => prevCart.filter(item => item.product.id !== productId));
  }, []);

  // 액션: 쿠폰 적용 (상태 변경)
  const applyCoupon = useCallback((coupon: Coupon) => {
    setSelectedCoupon(coupon);
  }, []);

  return {
    cart,
    selectedCoupon,
    addToCart,
    removeFromCart,
    applyCoupon,
  };
}
```

### 액션 최소화 전략

#### 1. 계산과 액션 분리
```typescript
// ❌ 나쁜 예: 계산과 액션이 섞여 있음
function addToCartAndCalculate(cart: CartItem[], product: Product) {
  const newCart = [...cart, { product, quantity: 1 }];
  const total = newCart.reduce((sum, item) => sum + item.product.price * item.quantity, 0);
  setCart(newCart); // 액션
  return total; // 계산
}

// ✅ 좋은 예: 계산과 액션 분리
// 계산 함수
function addItemToCart(cart: CartItem[], product: Product): CartItem[] {
  return [...cart, { product, quantity: 1 }];
}

// 액션 함수
function addToCart(product: Product) {
  setCart(prevCart => addItemToCart(prevCart, product));
}
```

#### 2. 액션을 명확히 표시
```typescript
// 액션 함수는 명확한 네이밍 사용
const addToCart = useCallback(...);      // 액션
const removeFromCart = useCallback(...); // 액션
const updateQuantity = useCallback(...); // 액션

// 계산 함수는 명확한 네이밍 사용
const calculateTotal = useMemo(...);    // 계산
const getRemainingStock = useCallback(...); // 계산
```

#### 3. 액션 최소화
```typescript
// ❌ 나쁜 예: 불필요한 액션
function updateCart(cart: CartItem[]) {
  setCart(cart);
  localStorage.setItem('cart', JSON.stringify(cart));
  console.log('장바구니 업데이트됨');
  notifyUser('장바구니가 업데이트되었습니다');
}

// ✅ 좋은 예: 액션을 최소화하고 분리
function updateCart(cart: CartItem[]) {
  setCart(cart); // 상태 변경만
}

// localStorage 동기화는 useEffect로 분리
useEffect(() => {
  localStorage.setItem('cart', JSON.stringify(cart));
}, [cart]);
```

---

## 4. 액션, 계산, 데이터 분리 전략

### 계층 구조

```
┌─────────────────────────────────────┐
│         UI Components              │  ← 액션 호출
├─────────────────────────────────────┤
│         Hooks (액션)               │  ← 상태 관리, 부수 효과
├─────────────────────────────────────┤
│    계산 함수 (순수 함수)            │  ← 데이터 변환
├─────────────────────────────────────┤
│         데이터 (타입)               │  ← 불변 데이터
└─────────────────────────────────────┘
```

### 실제 프로젝트 적용 예시

#### Before: 계산과 액션이 섞여 있는 코드
```typescript
// ❌ 나쁜 예
export function useCart() {
  const [cart, setCart] = useState<CartItem[]>([]);
  
  const calculateTotal = useCallback(() => {
    // 계산 로직이 Hook 내부에 있음
    let total = 0;
    cart.forEach(item => {
      total += item.product.price * item.quantity;
    });
    return total;
  }, [cart]);
  
  const addToCart = useCallback((product: Product) => {
    // 계산과 액션이 섞여 있음
    const existingItem = cart.find(item => item.product.id === product.id);
    if (existingItem) {
      setCart(prev => prev.map(item => 
        item.product.id === product.id 
          ? { ...item, quantity: item.quantity + 1 }
          : item
      ));
    } else {
      setCart(prev => [...prev, { product, quantity: 1 }]);
    }
  }, [cart]);
  
  return { cart, calculateTotal, addToCart };
}
```

#### After: 계산과 액션을 분리한 코드
```typescript
// ✅ 좋은 예: utils/cartCalculations.ts (계산)
export function addItemToCart(
  cart: CartItem[],
  product: Product
): CartItem[] {
  const existingItem = cart.find(item => item.product.id === product.id);
  if (existingItem) {
    return cart.map(item =>
      item.product.id === product.id
        ? { ...item, quantity: item.quantity + 1 }
        : item
    );
  }
  return [...cart, { product, quantity: 1 }];
}

export function calculateCartTotal(cart: CartItem[]): number {
  return cart.reduce(
    (sum, item) => sum + item.product.price * item.quantity,
    0
  );
}

// ✅ 좋은 예: hooks/useCart.ts (액션)
import { addItemToCart, calculateCartTotal } from '../utils/cartCalculations';

export function useCart() {
  const [cart, setCart] = useState<CartItem[]>([]);
  
  // 계산: 순수 함수 사용
  const total = useMemo(() => calculateCartTotal(cart), [cart]);
  
  // 액션: 상태 변경만 담당
  const addToCart = useCallback((product: Product) => {
    setCart(prevCart => addItemToCart(prevCart, product));
  }, []);
  
  return { cart, total, addToCart };
}
```

### 파일 구조 예시

```
src/
├── types.ts                    # 데이터 타입 정의
├── utils/
│   ├── cartCalculations.ts     # 계산 함수 (순수 함수)
│   └── productCalculations.ts  # 계산 함수 (순수 함수)
├── hooks/
│   ├── useCart.ts              # 액션 (상태 관리)
│   ├── useProducts.ts          # 액션 (상태 관리)
│   └── useCoupons.ts           # 액션 (상태 관리)
└── components/
    ├── entities/               # 엔티티 컴포넌트
    ├── features/               # 기능 컴포넌트
    └── ui/                     # UI 컴포넌트
```

---

## 5. 체크리스트

### 데이터
- [ ] 데이터 타입이 명확히 정의되어 있는가?
- [ ] 데이터를 직접 변경하지 않고 새로운 데이터를 생성하는가?
- [ ] 불변성을 유지하고 있는가?

### 계산
- [ ] 계산 함수가 순수 함수로 작성되어 있는가?
- [ ] 계산 함수가 외부 상태에 의존하지 않는가?
- [ ] 계산 함수가 별도 파일로 분리되어 있는가?
- [ ] 계산 함수가 독립적으로 테스트 가능한가?

### 액션
- [ ] 액션이 최소화되어 있는가?
- [ ] 계산과 액션이 명확히 분리되어 있는가?
- [ ] 액션 함수의 네이밍이 명확한가?
- [ ] 부수 효과가 명확히 표시되어 있는가?

### 구조
- [ ] 데이터 → 계산 → 액션 순서의 의존성이 올바른가?
- [ ] 하위 레이어가 상위 레이어를 import하지 않는가?
- [ ] 각 파일의 역할이 명확한가?

---

## 6. 실전 팁

### 1. 계산 함수를 먼저 작성
```typescript
// 1단계: 계산 함수 작성 (순수 함수)
function calculateDiscount(price: number, rate: number): number {
  return price * rate;
}

// 2단계: 액션에서 계산 함수 사용
function applyDiscount(price: number, rate: number) {
  const discountedPrice = calculateDiscount(price, rate);
  setPrice(discountedPrice);
}
```

### 2. 데이터 변환은 계산으로
```typescript
// ✅ 좋은 예: 데이터 변환은 계산 함수로
function filterProducts(products: Product[], searchTerm: string): Product[] {
  return products.filter(product => 
    product.name.toLowerCase().includes(searchTerm.toLowerCase())
  );
}

// ❌ 나쁜 예: 데이터 변환을 액션에서 처리
function searchProducts(searchTerm: string) {
  setProducts(prev => prev.filter(product => 
    product.name.toLowerCase().includes(searchTerm.toLowerCase())
  ));
}
```

### 3. 액션은 최소한으로
```typescript
// ✅ 좋은 예: 액션을 최소화
useEffect(() => {
  localStorage.setItem('cart', JSON.stringify(cart));
}, [cart]);

// ❌ 나쁜 예: 불필요한 액션
function saveCart() {
  localStorage.setItem('cart', JSON.stringify(cart));
  console.log('저장 완료');
  notifyUser('저장되었습니다');
}
```

### 4. 테스트 용이성 고려
```typescript
// ✅ 좋은 예: 계산 함수는 테스트하기 쉬움
describe('calculateCartTotal', () => {
  it('should calculate total correctly', () => {
    const cart: CartItem[] = [
      { product: { id: '1', price: 1000, ... }, quantity: 2 },
      { product: { id: '2', price: 2000, ... }, quantity: 1 },
    ];
    expect(calculateCartTotal(cart)).toBe(4000);
  });
});

// ❌ 나쁜 예: 액션은 테스트하기 어려움 (외부 상태 의존)
describe('useCart hook', () => {
  it('should calculate total', () => {
    // 복잡한 setup 필요, 외부 상태 모킹 필요
  });
});
```

---

## 7. 요약

### 핵심 원칙
1. **데이터**: 불변성을 유지하고, 타입을 명확히 정의
2. **계산**: 순수 함수로 작성하고, 별도 파일로 분리
3. **액션**: 최소화하고, 계산과 명확히 분리

### 이점
- **가독성**: 각 코드의 역할이 명확함
- **유지보수성**: 변경 사항이 명확하게 격리됨
- **테스트 용이성**: 계산 함수는 독립적으로 테스트 가능
- **재사용성**: 계산 함수는 다양한 컨텍스트에서 재사용 가능
- **예측 가능성**: 순수 함수는 항상 같은 결과를 반환

### 적용 순서
1. 데이터 타입 정의
2. 계산 함수 작성 (순수 함수)
3. 액션 작성 (상태 관리, 부수 효과)
4. UI 컴포넌트에서 액션 호출

---

## 참고 자료
- [함수형 프로그래밍 기초](https://velog.io/@teo/functional-programming)
- [함수형 프로그래밍 스터디](https://velog.io/@teo/functional-programming-study)

