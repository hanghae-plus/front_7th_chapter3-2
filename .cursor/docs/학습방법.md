# React Hook 및 함수형 프로그래밍 학습 가이드

## 📚 학습 목표

이 가이드를 통해 다음을 학습합니다:
1. React Hook의 올바른 사용법과 분리 원칙
2. 함수형 프로그래밍 패러다임 이해
3. 액션과 순수함수의 분리
4. 엔티티 기반 아키텍처 설계
5. 계층적 구조와 의존성 관리

---

## 🎯 핵심 개념 이해

### 1. React Hook 이해하기

#### 학습 단계
1. **기본 Hook 이해**
   - `useState`, `useEffect`, `useCallback`, `useMemo`의 역할과 사용 시기
   - 각 Hook의 의존성 배열과 최적화 전략

2. **Custom Hook 설계 원칙**
   - 단일 책임 원칙: 하나의 Hook은 하나의 관심사만 처리
   - 재사용성: 비즈니스 로직을 Hook으로 추출하여 재사용
   - 테스트 가능성: Hook을 독립적으로 테스트 가능하도록 설계

#### 실습 예제
```typescript
// ❌ 나쁜 예: 컴포넌트에 모든 로직이 포함
const Cart = () => {
  const [cart, setCart] = useState([]);
  const [total, setTotal] = useState(0);
  
  // 비즈니스 로직이 컴포넌트에 직접 포함
  const addItem = (item) => {
    // 복잡한 로직...
  };
  
  // 계산 로직도 컴포넌트에 포함
  useEffect(() => {
    const sum = cart.reduce(...);
    setTotal(sum);
  }, [cart]);
};

// ✅ 좋은 예: Hook으로 분리
const useCart = () => {
  const [cart, setCart] = useState([]);
  
  const addItem = useCallback((item) => {
    // 비즈니스 로직
  }, []);
  
  return { cart, addItem };
};

const useCartTotal = (cart) => {
  return useMemo(() => {
    return cart.reduce((sum, item) => sum + item.price, 0);
  }, [cart]);
};
```

---

### 2. 함수형 프로그래밍 이해

#### 핵심 원칙
1. **순수함수 (Pure Functions)**
   - 같은 입력에 항상 같은 출력
   - 부수 효과(side effect) 없음
   - 외부 상태에 의존하지 않음

2. **불변성 (Immutability)**
   - 데이터를 직접 수정하지 않고 새로운 객체 생성
   - React의 상태 업데이트 원칙과 일치

#### 학습 체크리스트
- [ ] 모든 계산 함수가 순수함수로 작성되었는가?
- [ ] 함수가 외부 변수에 의존하지 않는가?
- [ ] 함수가 부수 효과를 발생시키지 않는가?

#### 실습 예제
```typescript
// ❌ 나쁜 예: 부수 효과가 있는 함수
let total = 0;
const calculateTotal = (items) => {
  total = 0; // 외부 변수 수정
  items.forEach(item => {
    total += item.price; // 외부 변수에 의존
  });
  console.log(total); // 부수 효과
  return total;
};

// ✅ 좋은 예: 순수함수
const calculateTotal = (items: CartItem[]): number => {
  return items.reduce((sum, item) => sum + item.price, 0);
};
```

---

### 3. 액션과 순수함수의 분리

#### 개념 이해
- **액션 (Actions)**: 상태를 변경하는 함수 (부수 효과 있음)
- **순수함수 (Pure Functions)**: 계산만 수행하는 함수 (부수 효과 없음)

#### 분리 전략
1. **계산 로직 → 순수함수로 분리**
   - `calculateCartTotal(cart)`
   - `getDiscountRate(quantity)`
   - `formatPrice(amount)`

2. **상태 변경 로직 → Hook의 액션으로 분리**
   - `addToCart(item)`
   - `removeFromCart(id)`
   - `updateQuantity(id, quantity)`

#### 실습 예제
```typescript
// 순수함수: 계산만 수행
const calculateCartTotal = (cart: CartItem[]): number => {
  return cart.reduce((sum, item) => sum + item.price * item.quantity, 0);
};

const applyDiscount = (total: number, discountRate: number): number => {
  return total * (1 - discountRate);
};

// Hook: 액션과 상태 관리
const useCart = () => {
  const [cart, setCart] = useState<CartItem[]>([]);
  
  // 액션: 상태를 변경
  const addToCart = useCallback((item: Product) => {
    setCart(prev => [...prev, { ...item, quantity: 1 }]);
  }, []);
  
  // 계산은 순수함수 사용
  const total = useMemo(() => calculateCartTotal(cart), [cart]);
  
  return { cart, addToCart, total };
};
```

---

## 🏗️ 아키텍처 설계 원칙

### 1. 엔티티 기반 분리

#### 엔티티를 다루는 것 vs 그렇지 않은 것

**엔티티를 다루는 것:**
- 상태: `cart`, `products`, `user`
- 컴포넌트: `CartItemView`, `ProductCard`
- Hook: `useCart()`, `useProduct()`, `useUser()`
- 함수: `calculateCartTotal(cart)`, `getProductById(id)`

**엔티티를 다루지 않는 것:**
- 상태: `isShowPopup`, `isLoading`, `theme`
- 컴포넌트: `Button`, `Modal`, `Input`
- Hook: `useRoute()`, `useEvent()`, `useToggle()`
- 함수: `capitalize(str)`, `formatDate(date)`, `debounce(fn)`

#### 학습 방법
1. **코드 분석하기**
   - 기존 코드에서 엔티티 관련 코드와 UI 관련 코드 구분
   - 각각의 책임과 의존성 파악

2. **리팩토링 연습**
   - 엔티티 로직을 별도 Hook으로 추출
   - UI 로직을 범용 Hook으로 분리

---

### 2. 계층 구조 이해

#### 권장 계층 구조
```
entities (도메인 모델)
  ↓
features (비즈니스 로직)
  ↓
UI (컴포넌트)
```

#### 각 계층의 책임

**Entities 계층:**
- 도메인 모델 정의
- 타입 정의
- 순수한 데이터 구조

**Features 계층:**
- 비즈니스 로직
- Custom Hook
- 순수함수 (계산 로직)

**UI 계층:**
- 컴포넌트
- 프레젠테이션 로직
- 사용자 인터랙션 처리

#### 실습 예제
```typescript
// entities/cart.ts
export interface CartItem {
  id: string;
  product: Product;
  quantity: number;
}

// features/useCart.ts
import { CartItem } from '../entities/cart';

export const useCart = () => {
  const [cart, setCart] = useState<CartItem[]>([]);
  // 비즈니스 로직...
};

// UI/CartView.tsx
import { useCart } from '../features/useCart';

export const CartView = () => {
  const { cart, addItem } = useCart();
  // UI 렌더링...
};
```

---

## 📋 기본과제 학습 체크리스트

### 1단계: 비즈니스 로직 분리
- [ ] 컴포넌트에서 데이터가 아닌 로직을 Hook으로 이동
- [ ] 각 Hook이 단일 책임을 가지도록 분리
- [ ] Hook 간 의존성 최소화

### 2단계: 순수함수 작성
- [ ] 모든 계산 함수를 순수함수로 작성
- [ ] 함수가 외부 상태에 의존하지 않도록 설계
- [ ] 부수 효과를 제거

### 3단계: 엔티티 함수 분리
- [ ] 특정 엔티티만 다루는 함수를 별도 모듈로 분리
- [ ] 엔티티 관련 함수와 범용 함수 구분
- [ ] 함수의 재사용성 고려

### 4단계: 컴포넌트 분리
- [ ] 엔티티를 다루는 컴포넌트와 UI 컴포넌트 분리
- [ ] 프레젠테이션 컴포넌트와 컨테이너 컴포넌트 구분
- [ ] 컴포넌트의 재사용성 향상

### 5단계: 계층 구조 설계
- [ ] entities → features → UI 계층 구조 구현
- [ ] 의존성 방향이 올바른지 확인 (상위 계층이 하위 계층에 의존)
- [ ] 순환 의존성 제거

---

## 🚀 심화과제 학습 가이드

### Props Drilling 문제 이해

#### 문제 상황
```typescript
// Props가 여러 계층을 거쳐 전달됨
<App>
  <Header user={user} />
  <Main>
    <ProductList user={user} />
    <Cart user={user} />
  </Main>
</App>
```

#### 해결 방법: Context API 또는 Jotai

### 1단계: 전역 상태 관리 구축

#### Context API 사용
```typescript
// contexts/UserContext.tsx
const UserContext = createContext<User | null>(null);

export const UserProvider = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
};

export const useUser = () => {
  const context = useContext(UserContext);
  if (!context) throw new Error('useUser must be used within UserProvider');
  return context;
};
```

#### Jotai 사용
```typescript
// atoms/user.ts
import { atom } from 'jotai';

export const userAtom = atom<User | null>(null);
```

### 2단계: Props 선택 기준

#### 남겨야 할 Props
- **도메인 Props**: 컴포넌트의 핵심 기능에 필요한 데이터
  - `ProductCard`의 `product` prop
  - `CartItem`의 `item` prop
- **콜백 Props**: 컴포넌트 특화된 이벤트 핸들러
  - `onProductClick(product)`
  - `onQuantityChange(id, quantity)`

#### 제거해야 할 Props
- **전역 상태**: 여러 컴포넌트에서 공유되는 상태
  - `user`, `theme`, `language`
- **Drilling Props**: 중간 컴포넌트에서 사용하지 않는 props
  - 단순히 전달만 하는 props

### 3단계: 리팩토링 체크리스트
- [ ] Context나 Jotai로 전역 상태 관리 구축
- [ ] Domain custom hook을 전역 상태에 맞게 리팩토링
- [ ] 도메인 props는 유지하고 drilling props 제거
- [ ] 결합도가 낮아지고 재조립이 쉬워졌는지 확인

---

## 📖 학습 리소스

### 추천 학습 순서

1. **기초 단계 (1주)**
   - React Hook 공식 문서 읽기
   - 함수형 프로그래밍 기초 개념 학습
   - 순수함수와 부수 효과 이해

2. **실습 단계 (2주)**
   - 기존 코드 분석 및 리팩토링
   - Hook 분리 연습
   - 순수함수 작성 연습

3. **심화 단계 (1주)**
   - Context API 또는 Jotai 학습
   - Props drilling 제거 실습
   - 아키텍처 설계 연습

### 참고 자료
- [React Hooks 공식 문서](https://react.dev/reference/react)
- [함수형 프로그래밍 가이드](https://github.com/getify/Functional-Light-JS)
- [Clean Architecture in React](https://kentcdodds.com/blog/colocation)

---

## ✅ 최종 체크리스트

### 코드 품질 확인
- [ ] 모든 비즈니스 로직이 Hook으로 분리되었는가?
- [ ] 계산 함수가 순수함수로 작성되었는가?
- [ ] 엔티티 관련 코드와 UI 코드가 분리되었는가?
- [ ] 계층 구조가 올바르게 설계되었는가?
- [ ] Props drilling이 적절히 제거되었는가?
- [ ] 코드의 재사용성과 테스트 가능성이 향상되었는가?

### 아키텍처 확인
- [ ] entities → features → UI 계층 구조가 명확한가?
- [ ] 의존성 방향이 올바른가? (상위 → 하위)
- [ ] 각 모듈의 책임이 명확한가?
- [ ] 결합도가 낮고 응집도가 높은가?

---

## 🎓 학습 팁

1. **작은 단계로 시작**: 한 번에 모든 것을 바꾸지 말고 점진적으로 리팩토링
2. **테스트 작성**: 리팩토링 전후 동작이 동일한지 확인
3. **코드 리뷰**: 다른 사람의 코드를 보고 패턴 학습
4. **실무 적용**: 학습한 내용을 실제 프로젝트에 적용해보기

---

## 📝 회고 질문

과제를 완료한 후 다음 질문에 답해보세요:

1. **알게된 점, 좋았던 점**
   - 어떤 개념이 가장 도움이 되었나요?
   - 어떤 패턴이 가장 효과적이었나요?

2. **신경 쓴 부분**
   - 어떤 부분에 가장 많은 시간을 투자했나요?
   - 어떤 결정이 가장 중요했나요?

3. **앞으로 해보고 싶은 것**
   - 다음에 어떤 기술을 학습하고 싶나요?
   - 어떤 프로젝트에 적용해보고 싶나요?

4. **리뷰 받고 싶은 내용**
   - 어떤 부분이 가장 불확실한가요?
   - 어떤 부분에 대한 피드백을 원하시나요?

---

**마지막 업데이트**: 2025-12-01

