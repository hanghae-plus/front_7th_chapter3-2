# 적용된 주요 디자인 패턴

지금까지 리팩토링을 진행하면서 우리 코드에 적용된 주요 디자인 패턴들을 소개합니다.

---

### 1. 컨테이너 / 프레젠테이셔널 패턴 (Container / Presentational Pattern)

"스마트 컴포넌트"와 "덤(Dumb) 컴포넌트"로 역할을 나누는 방식입니다.

-   **컨테이너(Container) 컴포넌트 (스마트):** "어떻게 동작할 것인가"에 집중합니다.
    -   상태 관리, 데이터 로딩, 비즈니스 로직 등을 처리합니다.
    -   자식 컴포넌트에 필요한 데이터와 함수를 `props`로 내려주는 역할을 합니다.
-   **프레젠테이셔널(Presentational) 컴포넌트 (덤):** "어떻게 보일 것인가"에 집중합니다.
    -   `props`로 받은 데이터를 화면에 그리는 역할만 합니다.
    -   자체적으로 상태를 거의 갖지 않으며, UI와 스타일에만 집중합니다.

-   **적용 예시:**
    -   `AdminContainer.tsx`는 `activeTab` 상태를 관리하고, `AdminProduct`와 `AdminCoupon` 중 무엇을 보여줄지 결정하는 **컨테이너**입니다.
    -   `AdminProduct.tsx`와 `AdminCoupon.tsx`은 `props`로 받은 상품/쿠폰 데이터를 화면에 그리고, 버튼 클릭 시 `props`로 받은 함수를 호출만 하는 **프레젠테이셔널** 컴포넌트입니다.
    -   `CartContainer.tsx` 역시 `Products.tsx`와 `Cart.tsx`를 조합하는 **컨테이너**의 역할을 합니다.

-   **장점:**
    -   **재사용성:** `AdminProduct` 같은 프레젠테이셔널 컴포넌트는 다른 곳에서도 상품 목록을 보여줄 때 재사용하기 쉬워집니다.
    -   **관심사 분리:** 데이터 로직과 UI 렌더링 로직이 분리되어 코드를 이해하고 수정하기 훨씬 쉬워졌습니다.


### 2. 커스텀 훅 패턴 (Custom Hook Pattern)

React의 가장 강력한 패턴 중 하나로, **상태 관련 로직을 컴포넌트에서 분리하여 재사용 가능한 함수로 만드는 것**입니다.

-   **적용 예시:**
    -   `useCart.ts`, `useProducts.ts`, `useCoupons.ts`, `useNotifications.ts`가 바로 이 패턴의 결과물입니다.
    -   예를 들어, `useNotifications` 훅은 알림과 관련된 모든 것(`notifications` 상태, `addNotification`, `removeNotification`, `setTimeout` 로직)을 하나의 "패키지"로 묶어 제공합니다.

-   **장점:**
    -   **로직 캡슐화:** `App.tsx`는 더 이상 알림이 어떻게 동작하는지 알 필요가 없습니다. 그냥 `useNotifications()` 훅을 호출해서 필요한 함수를 꺼내 쓰기만 하면 됩니다.
    -   **재사용성:** 만약 다른 페이지에서도 알림 기능이 필요하다면, `useNotifications()` 훅을 호출하기만 하면 됩니다.
    -   **가독성:** `App.tsx`에서 복잡한 `useEffect`와 `useState`들이 사라지고, `const { ... } = use...()` 형태의 간결한 코드가 남아 전체 구조를 파악하기 쉬워졌습니다.

### 3. 의존성 주입 패턴 (Dependency Injection Pattern)

"내가 필요한 것을 직접 만들지 않고, 외부에서 만들어서 넣어주는" 방식입니다.

-   **적용 예시:**
    -   가장 좋은 예시는 `useCart`, `useProducts` 등의 훅이 `addNotification` 함수를 **인자(argument)로 받아오는 부분**입니다.
    -   `useCart` 훅은 알림을 띄워야 하지만, *어떻게* 띄울지에 대해서는 책임지지 않습니다. 그저 외부에서 주입된 `addNotification` 함수를 호출할 뿐입니다.

-   **장점:**
    -   **결합도 감소(Decoupling):** `useCart` 훅은 특정 알림 구현(예: `NotificationContainer`)에 의존하지 않게 됩니다. 나중에 알림 라이브러리를 바꾸더라도 `useCart` 훅은 수정할 필요가 없습니다.
    -   **테스트 용이성:** `useCart` 훅을 테스트할 때, 실제 알림 함수 대신 "호출되었는지"만 검사하는 가짜(mock) 함수를 쉽게 주입할 수 있습니다.

### 4. 퍼사드 패턴 (Facade Pattern)

복잡한 서브시스템에 대한 간단한 통합 인터페이스를 제공하는 패턴입니다. 사용자는 복잡한 내부를 몰라도, 간단한 외관(Facade)만 보고 쉽게 사용할 수 있습니다.

-   **적용 예시:**
    -   우리가 만든 **모든 커스텀 훅**이 이 패턴의 훌륭한 예시입니다.
    -   `useCart` 훅을 사용하는 컴포넌트는 `localStorage` 동기화, 재고 계산, 할인율 계산, 상태 업데이트 등 복잡한 내부 동작을 전혀 알 필요가 없습니다. 오직 `addToCart(product)`라는 간단한 함수만 호출하면, 훅이 알아서 모든 복잡한 일을 처리해 줍니다. `useCart`가 '장바구니 서브시스템'의 간단한 외관(Facade) 역할을 하는 것입니다.

-   **장점:**
    -   **사용 편의성:** 컴포넌트에서는 복잡한 로직 없이 `addToCart`만 호출하면 되므로 코드가 매우 깔끔해집니다.
    -   **캡슐화:** 장바구니 관련 로직을 수정해야 할 때, `useCart.ts` 파일만 보면 되므로 유지보수가 쉬워집니다.

---

### 요약

| 적용된 패턴 | 간단한 설명 | 우리 코드의 예시 |
| :--- | :--- | :--- |
| **컨테이너 / 프레젠테이셔널** | 똑똑한 놈(로직)과 예쁜 놈(UI)의 역할 분리 | `AdminContainer`와 `AdminProduct` |
| **커스텀 훅** | 재사용 가능한 상태 관리 로직 패키지 | `useCart`, `useNotifications` |
| **의존성 주입** | 필요한 기능을 외부에서 만들어서 넣어줌 | 훅에 `addNotification` 함수를 인자로 전달 |
| **퍼사드** | 복잡한 내부를 숨기고 간단한 사용법만 제공 | `useCart` 훅 자체가 `addToCart`라는 간단한 외관 제공 |
