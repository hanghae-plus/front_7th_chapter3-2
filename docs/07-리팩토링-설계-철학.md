# 리팩토링 설계 철학

## 1. 관심사의 분리 (Separation of Concerns)

### 리팩토링 전 (모놀리식)

```
┌─────────────────────────────────────────────────────────────┐
│                        App.tsx                               │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐           │
│  │ 상태    │ │ 비즈니스│ │ UI      │ │ 부작용  │ ← 전부 섞임 │
│  │ 관리    │ │ 로직    │ │ 렌더링  │ │ (API등) │           │
│  └─────────┘ └─────────┘ └─────────┘ └─────────┘           │
└─────────────────────────────────────────────────────────────┘
```

### 리팩토링 후 (분리된 구조)

```
┌─────────────────────────────────────────────────────────────┐
│ models/     │ hooks/        │ components/  │ utils/         │
│ (순수계산)   │ (상태+액션)    │ (UI만)       │ (범용도구)      │
│             │               │              │               │
│ cart.ts     │ useProducts   │ CartPage     │ formatter.ts  │
│ - 할인계산   │ useCart       │ AdminPage    │ - 포맷팅      │
│ - 총액계산   │ useCoupons    │ Button       │               │
└─────────────────────────────────────────────────────────────┘
```

## 2. 계층별 역할과 특징

| 계층 | 역할 | 특징 | 예시 |
|------|------|------|------|
| **models** | 비즈니스 로직 (순수함수) | 테스트 쉬움, 재사용 가능, 입력→출력만 | `calculateCartTotal(cart, coupon)` |
| **hooks** | 상태 + 액션 (부작용 포함) | React에 종속, localStorage 등 | `useProducts()`, `useCart()` |
| **components** | UI 렌더링만 | 로직 없이 데이터 받아서 그리기만 | `<CartItem item={item} />` |
| **utils** | 범용 도구 | 도메인과 무관 | `formatPrice(1000)` → "₩1,000" |

## 3. 코드 배치 결정 기준

### 질문 1: "이 함수는 React 없이 실행할 수 있나?"

- **Yes** → `models/` (순수함수)
- **No** → `hooks/`

### 질문 2: "이 함수는 특정 도메인에 종속적인가?"

- **Yes** → `models/` 또는 도메인 훅
- **No** → `utils/` (범용)

### 질문 3: "이 컴포넌트는 상태를 직접 관리하나?"

- **직접 관리** → Container/Page 컴포넌트
- **전달받음** → Presentational 컴포넌트

### 질문 4: "이 코드가 변경되면 뭐가 영향받나?"

- 할인 정책 변경 → `models/cart.ts`만 수정
- UI 디자인 변경 → `components/`만 수정
- localStorage 방식 변경 → `hooks/`만 수정

## 4. 리팩토링 진행 구조

```
App.tsx (모놀리식)
    │
    ├── models/cart.ts        ← "계산" 분리 (순수함수)
    │   └── React 없이도 동작 (테스트 용이)
    │
    ├── utils/formatter.ts    ← "범용 도구" 분리
    │   └── 도메인과 무관하게 어디서든 사용 가능
    │
    ├── hooks/useDebounce.ts  ← "범용 훅" 분리
    │   └── 어떤 값이든 디바운싱 가능
    │
    ├── hooks/useProducts.ts  ← "도메인 상태+액션" 분리
    │   └── 상품 관련 모든 것을 캡슐화
    │
    └── constants/index.ts    ← "초기 데이터" 분리
        └── 하드코딩된 값들을 한 곳에서 관리
```

## 5. 핵심 원칙

> **변경의 이유가 같은 코드는 함께, 다른 코드는 분리하라**

- 할인 정책이 바뀌면 → `models/`만 수정
- UI가 바뀌면 → `components/`만 수정
- 저장 방식이 바뀌면 → `hooks/`만 수정
- 포맷 형식이 바뀌면 → `utils/`만 수정

