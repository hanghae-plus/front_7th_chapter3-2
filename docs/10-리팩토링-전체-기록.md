# 리팩토링 전체 기록

## 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [리팩토링 순서](#2-리팩토링-순서)
3. [순수 함수 분리](#3-순수-함수-분리)
4. [커스텀 훅 설계](#4-커스텀-훅-설계)
5. [컴포넌트 분리 전략](#5-컴포넌트-분리-전략)
6. [Props Drilling 최소화](#6-props-drilling-최소화)
7. [응집도와 결합도 분석](#7-응집도와-결합도-분석)
8. [디렉토리 구조 결정](#8-디렉토리-구조-결정)
9. [주요 설계 결정 및 이유](#9-주요-설계-결정-및-이유)
10. [발생한 문제와 해결](#10-발생한-문제와-해결)

---

## 1. 프로젝트 개요

### 목표
- 773줄의 모놀리식 `App.tsx`를 기능별로 분리
- 함수형 프로그래밍 원칙 적용 (데이터/계산/액션 분리)
- Props Drilling 최소화 (Context 없이 기본 과제)
- 높은 응집도, 낮은 결합도 달성

### 최종 결과
```
App.tsx: 773줄 → 92줄 (88% 감소)
```

---

## 2. 리팩토링 순서

```
1단계: 순수 함수 분리
   └── models/cart.ts (장바구니 비즈니스 로직)
   └── utils/formatter.ts (포맷팅 유틸리티)

2단계: 상수 분리
   └── constants/index.ts (초기 데이터)

3단계: 커스텀 훅 생성
   └── useDebounce.ts
   └── useProducts.ts
   └── useCoupons.ts
   └── useCart.ts
   └── useNotification.ts

4단계: 공통 컴포넌트 분리
   └── Header.tsx (Compound Components 패턴)
   └── Button.tsx
   └── Badge.tsx
   └── Toast.tsx / ToastContainer.tsx

5단계: Feature 컴포넌트 분리
   └── SearchInput.tsx
   └── CartIcon.tsx
   └── ProductList.tsx / ProductItem.tsx
   └── CartList.tsx / CartItem.tsx
   └── CheckoutSection.tsx

6단계: 페이지 분리
   └── MainPage.tsx
   └── AdminPage.tsx
```

---

## 3. 순수 함수 분리

### 질문: "props Drilling을 최소화하는 방법이 뭐가 있을까"

**답변 요약:**
- 순수 함수 자체는 props drilling과 무관
- 순수 함수는 **입력 → 출력만** 하므로 어디서든 import해서 사용 가능
- props drilling은 **상태(state)**를 전달할 때 발생

### models/cart.ts - 장바구니 비즈니스 로직

```typescript
// 모든 함수가 순수 함수 (같은 입력 → 같은 출력)
export const getMaxApplicableDiscount = (item: CartItem): number
export const calculateItemTotal = (item: CartItem, cart: CartItem[]): number
export const calculateCartTotal = (cart: CartItem[], selectedCoupon: Coupon | null): CartTotals
export const getRemainingStock = (product: Product, cart: CartItem[]): number
export const addItemToCart = (cart: CartItem[], product: Product): CartItem[]
export const removeItemFromCart = (cart: CartItem[], productId: string): CartItem[]
export const updateCartItemQuantity = (cart: CartItem[], productId: string, quantity: number): CartItem[]
export const canAddToCart = (product: Product, cart: CartItem[]): boolean
export const getTotalItemCount = (cart: CartItem[]): number
```

**핵심 원칙:**
- `cart`를 파라미터로 받음 (외부 상태 참조 X)
- 새로운 배열/객체 반환 (기존 데이터 변경 X)
- side effect 없음 (localStorage, API 호출 X)

### utils/formatter.ts - 포맷팅 유틸리티

```typescript
export const formatPrice = (price: number): string
export const formatPriceKorean = (price: number): string  
export const formatPercentage = (value: number): string
```

**models vs utils 구분:**
- `models/`: 도메인 비즈니스 로직 (장바구니, 할인 계산)
- `utils/`: 범용 유틸리티 (포맷팅, 날짜, 문자열)

---

## 4. 커스텀 훅 설계

### 질문: "커스텀 훅은 컨텍스트를 사용하지 않아?"

**답변:**
```
Hook ≠ Context

Hook: 로직 캡슐화 (각 호출마다 독립적인 상태)
Context: 상태 공유 (트리 전체에서 같은 상태)
```

| 특성 | Hook만 사용 | Hook + Context |
|------|------------|----------------|
| 상태 범위 | 컴포넌트 로컬 | 전역 공유 |
| 재사용성 | 높음 | 높음 |
| Props Drilling | 필요함 | 불필요 |

### useDebounce.ts

```typescript
export function useDebounce<T>(value: T, delay: number): T
```

**디바운싱 vs 쓰로틀링:**
| | 디바운싱 | 쓰로틀링 |
|--|---------|---------|
| 실행 시점 | 마지막 이벤트 후 | 일정 간격마다 |
| 사용 예 | 검색 입력 | 스크롤, 리사이즈 |

### useProducts.ts

```typescript
export function useProducts() {
  const [products, setProducts] = useState<ProductWithUI[]>()
  
  // localStorage 동기화 포함
  useEffect(() => {
    localStorage.setItem('products', JSON.stringify(products))
  }, [products])
  
  return { products, addProduct, updateProduct, deleteProduct }
}
```

### useCoupons.ts

```typescript
export function useCoupons() {
  return { 
    coupons, 
    addCoupon: () => ({ success, message }),  // Result Pattern
    deleteCoupon: () => ({ success, message })
  }
}
```

**Result Pattern 적용 이유:**
- 훅 내부에서 notification 호출하면 훅이 UI에 의존
- result 반환 → 호출하는 쪽에서 notification 처리
- **관심사 분리**: 비즈니스 로직 ↔ UI 피드백

### useCart.ts

```typescript
export function useCart(products: ProductWithUI[]) {  // 의존성 주입
  return {
    cart,
    selectedCoupon,
    addToCart: () => ({ success, message }),
    removeFromCart: () => ({ success, message }),
    updateQuantity: () => ({ success, message }),
    applyCoupon: () => ({ success, message }),
    removeCoupon,
    completeOrder: () => ({ success, message }),
    totals
  }
}
```

**의존성 주입 (Dependency Injection):**
```typescript
// ❌ 훅 내부에서 products 관리
const { cart } = useCart()  // products를 어떻게 알지?

// ✅ 외부에서 products 주입
const { products } = useProducts()
const { cart } = useCart(products)  // 재고 체크 가능
```

### useNotification.ts

```typescript
export function useNotification(autoHideDuration = 3000) {
  return { notifications, addNotification, removeNotification }
}
```

---

## 5. 컴포넌트 분리 전략

### 질문: "Header에서 searchTerm이나 장바구니 버튼을 관리하지 않고 app에서 관리하고 싶은데"

**Compound Components 패턴 적용:**

```tsx
// 사용 예
<Header.Root>
  <Header.Left>
    <Header.Logo />
    <SearchInput />
    <CartIcon />
  </Header.Left>
  <Header.Right>
    <Header.AdminToggle isAdmin={isAdmin} onToggle={setIsAdmin} />
  </Header.Right>
</Header.Root>
```

**장점:**
- 레이아웃(Header)과 내용물(SearchInput, CartIcon) 분리
- 유연한 컴포지션
- AdminToggle은 Header 내부에서 관리 (일관성 유지)

### 질문: "MainPageInput은 어디다 넣어야함?"

**디렉토리 구조 결정:**
```
src/
├── components/          # 공통 UI (2개 이상 페이지에서 사용)
│   ├── Header.tsx
│   ├── Button.tsx
│   ├── Badge.tsx
│   └── Toast.tsx
├── features/           # 도메인별 기능 컴포넌트
│   └── main/
│       ├── SearchInput.tsx
│       ├── CartIcon.tsx
│       ├── ProductList.tsx
│       └── ...
└── pages/              # 페이지 컴포넌트
    ├── MainPage.tsx
    └── AdminPage.tsx
```

**features/main vs components 기준:**
| 기준 | components/ | features/main/ |
|------|-------------|----------------|
| 사용 범위 | 앱 전체 | 특정 페이지/도메인 |
| 예시 | Button, Badge | SearchInput, ProductItem |
| 의존성 | 없음 (순수 UI) | 도메인 타입 의존 |

### 질문: "features 디렉토리에 index.ts 넣어야 하는 이유가 뭐임"

**Barrel Export 패턴:**
```typescript
// features/index.ts
export { SearchInput } from './main/SearchInput'
export { CartIcon } from './main/CartIcon'
export { ProductList } from './main/ProductList'
```

**장점:**
```typescript
// Without barrel
import { SearchInput } from './features/main/SearchInput'
import { CartIcon } from './features/main/CartIcon'

// With barrel
import { SearchInput, CartIcon } from './features'
```

**단점:**
- 작은 프로젝트에서는 오버헤드
- Tree-shaking 문제 가능성

**결론:** 현재 프로젝트 규모에서는 선택사항

---

## 6. Props Drilling 최소화

### 질문: "useCart MainPage로 옮겨도 문제 없지?"

**문제:**
```
App (Header에서 totalItemCount 필요)
 └── MainPage (useCart 호출하고 싶음)
      └── CartIcon (totalItemCount 표시)
```

`useCart`를 `MainPage`로 옮기면 `Header`의 `CartIcon`이 `totalItemCount`를 받을 수 없음.

**해결: Callback Props 패턴**

```tsx
// MainPage.tsx
const { cart } = useCart(products)
const totalItemCount = getTotalItemCount(cart)

useEffect(() => {
  onTotalItemCountChange(totalItemCount)  // App으로 전달
}, [totalItemCount])

// App.tsx
const [totalItemCount, setTotalItemCount] = useState(0)

<MainPage 
  onTotalItemCountChange={setTotalItemCount}
/>
<Header>
  <CartIcon itemCount={totalItemCount} />
</Header>
```

### 질문: "calculateItemTotal 에러... 리팩토링 할 만한 방안이 있어?"

**문제:**
```typescript
// calculateItemTotal(item, cart) 시그니처
// CartItem에서 cart를 모름
```

**해결: 계산 위치 이동**

```tsx
// CartList.tsx에서 직접 계산
import { calculateItemTotal } from '../../models/cart'

cart.map(item => (
  <CartItem 
    item={item}
    itemTotal={calculateItemTotal(item, cart)}  // 여기서 계산
  />
))

// CartItem.tsx는 계산된 값만 받음
interface CartItemProps {
  item: CartItem
  itemTotal: number  // 이미 계산된 값
}
```

**원칙:** 데이터가 있는 곳에서 계산하고, 결과만 전달

---

## 7. 응집도와 결합도 분석

### 질문: "MainPage관련한 모든 컴포넌트들도 응집도와 결합도가 적합한지 판단해"

| 컴포넌트 | 응집도 | 결합도 | 평가 |
|---------|--------|--------|------|
| ProductList | ⭐⭐⭐⭐⭐ | ⭐ | 최적 |
| ProductItem | ⭐⭐⭐⭐⭐ | ⭐ | 최적 |
| CartList | ⭐⭐⭐⭐⭐ | ⭐ | 최적 |
| CartItem | ⭐⭐⭐⭐⭐ | ⭐ | 최적 |
| CheckoutSection | ⭐⭐⭐⭐ | ⭐⭐ | 양호 (분리 가능) |

**CheckoutSection 개선 가능:**
```
CheckoutSection (현재)
├── 쿠폰 선택 UI
└── 주문 요약 UI

→ 분리 가능
CouponSelect.tsx
OrderSummary.tsx
```

**ProductList 개선 가능:**
- `debouncedSearchTerm`은 메시지 표시에만 사용
- 제거하면 props 4개 → 3개
- 또는 일반 메시지로 변경: "검색 결과가 없습니다."

---

## 8. 디렉토리 구조 결정

### 질문: "저걸 추천하는 이유는 뭔데"

**기준:**
1. **재사용성**: 여러 곳에서 쓰이면 `components/`
2. **도메인 종속성**: 특정 도메인 타입에 의존하면 `features/`
3. **페이지 단위**: 라우트와 1:1 매칭되면 `pages/`

**최종 구조:**
```
src/basic/
├── components/        # 공통 UI
│   ├── Header.tsx
│   ├── Button.tsx
│   ├── Badge.tsx
│   ├── Toast.tsx
│   └── ToastContainer.tsx
├── features/          # 도메인별 기능
│   ├── index.ts
│   └── main/
│       ├── SearchInput.tsx
│       ├── CartIcon.tsx
│       ├── ProductList.tsx
│       ├── ProductItem.tsx
│       ├── CartList.tsx
│       ├── CartItem.tsx
│       └── CheckoutSection.tsx
├── hooks/             # 커스텀 훅
│   ├── useDebounce.ts
│   ├── useProducts.ts
│   ├── useCoupons.ts
│   ├── useCart.ts
│   └── useNotification.ts
├── models/            # 순수 비즈니스 로직
│   └── cart.ts
├── utils/             # 범용 유틸리티
│   └── formatter.ts
├── constants/         # 상수
│   └── index.ts
├── pages/             # 페이지
│   ├── MainPage.tsx
│   └── AdminPage.tsx
└── App.tsx            # 루트 (92줄)
```

---

## 9. 주요 설계 결정 및 이유

### Q: "보통 커머스에서 토스트 알림을 처리할 때 어떤 방식으로 구현함"

**일반적인 패턴:**
1. `Toast` (개별 알림) + `ToastContainer` (리스트 관리)
2. ToastContainer는 최상위에 렌더링
3. 전역 상태로 관리 (Context/Jotai)

**현재 구현 (기본 과제):**
```tsx
// App.tsx
const { notifications, addNotification, removeNotification } = useNotification()

<ToastContainer 
  notifications={notifications}
  removeNotification={removeNotification}
/>
```

### Q: "실제 커머스에서 order 섹션과 cart 섹션은 주로 분리하는 편임?"

**답변:**
- **대형 커머스**: 장바구니 페이지 / 결제 페이지 분리 (쿠팡, 11번가)
- **간소화 커머스**: 한 페이지에 통합 (작은 쇼핑몰)
- **현재 과제**: 한 페이지 통합 → `CheckoutSection`으로 그룹화

### Q: "useCoupons도 app에서 mainpage로 옮겨도 되지?"

**답변:**
- `MainPage`에서만 쿠폰 적용 → 옮겨도 됨
- **BUT** `AdminPage`에서 쿠폰 추가/삭제 → 상태 공유 필요
- 심화 과제(Context)에서 전역 관리 권장

### Q: "Jotai를 사용하는 경우라면?"

**Jotai 적용 시:**
```typescript
// atoms/notification.ts
export const notificationsAtom = atom<Notification[]>([])

// useNotification.ts
export function useNotification() {
  const [notifications, setNotifications] = useAtom(notificationsAtom)
  // ... 나머지 로직
}

// 어디서든 useNotification() 호출하면 같은 상태 공유
```

**장점:**
- Provider 불필요 (Context 대비)
- 코드 변경 최소화
- 어디서든 `addNotification` 호출 가능

---

## 10. 발생한 문제와 해결

### 1. ProductWithUI 중복 정의

**문제:** `App.tsx`와 `useProducts.ts` 양쪽에 정의됨

**해결:** `constants/index.ts`에서 export, 다른 곳에서 import

### 2. useCoupons에서 cart, addNotification 참조

**문제:** 쿠폰 적용 시 cart 상태 필요, notification도 필요

**해결:** 
- `useCoupons`: 쿠폰 CRUD만 담당 (Result Pattern)
- `useCart`: 쿠폰 적용 담당 (selectedCoupon 포함)
- notification은 호출하는 쪽에서 처리

### 3. useCart를 MainPage로 옮기면 Header에서 totalItemCount 접근 불가

**문제:** Context 없이 상태 공유 불가

**해결:** Callback Props 패턴
```tsx
<MainPage onTotalItemCountChange={setTotalItemCount} />
```

### 4. calculateItemTotal 시그니처 불일치

**문제:** `calculateItemTotal(item, cart)`인데 `CartItem`은 `cart`를 모름

**해결:** `CartList`에서 계산 후 `itemTotal`로 전달

### 5. AdminPage와 MainPage 상품 상태 동기화

**문제:** 각각 `useProducts()` 호출하면 별개 상태

**해결:** `App.tsx`에서 `useProducts()` 호출, props로 전달

### 6. Button 사이즈 불일치

**문제:** AdminToggle 버튼과 Add to Cart 버튼 사이즈가 다름

**해결:** `Button.tsx`의 `md` 사이즈에서 `text-sm` 제거

### 7. Header에 SearchInput/CartIcon 배치 고민

**문제:** Header는 common인데 SearchInput/CartIcon은 main 전용

**해결:** 
- Header는 `components/`에 (레이아웃 담당)
- SearchInput/CartIcon은 `features/main/`에 (Main 페이지 전용)
- Compound Components로 조합

---

## 커밋 히스토리

```
feat(basic): 순수 함수 분리 (models/cart.ts)
feat(basic): 유틸리티 함수 분리 (utils/formatter.ts)
feat(basic): useDebounce 훅 분리
feat(basic): 상수 분리 (constants/index.ts)
feat(basic): useProducts 훅 분리
feat(basic): useCoupons 훅 분리
feat(basic): useCart 훅 분리
feat(basic): useNotification 훅 분리
refactor(basic): Header Compound Components 패턴 적용
feat(basic): SearchInput, CartIcon 분리
feat(basic): Button 공통 컴포넌트 분리
feat(basic): Badge 공통 컴포넌트 분리
refactor(basic): MainPage 분리
refactor(basic): ProductList, ProductItem 분리
refactor(basic): CartList, CartItem 분리
refactor(basic): CheckoutSection 분리
feat(basic): Toast, ToastContainer 분리
refactor(basic): AdminPage 분리
```

---

## 다음 단계 (심화 과제)

1. **Context API 또는 Jotai로 전역 상태 관리**
   - products, coupons, cart를 전역으로
   - Props Drilling 완전 제거

2. **Compound Components 확장**
   - 더 많은 컴포넌트에 패턴 적용

3. **AdminPage 추가 분리**
   - ProductManagement, CouponManagement 컴포넌트화

